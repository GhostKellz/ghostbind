use anyhow::{anyhow, Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::cargo_integration::CrateInfo;

pub struct HeaderGenerator {
    cbindgen_config: Option<PathBuf>,
    cache_dir: PathBuf,
}

#[derive(Debug, Clone)]
pub struct GeneratedHeader {
    pub crate_name: String,
    pub header_path: PathBuf,
}

impl HeaderGenerator {
    pub fn new(cbindgen_config: Option<PathBuf>) -> Self {
        let cache_dir = PathBuf::from(".ghostbind/cache");

        Self {
            cbindgen_config,
            cache_dir,
        }
    }

    pub fn generate_headers(&self, crate_info: &CrateInfo, target_triple: Option<&str>) -> Result<Vec<GeneratedHeader>> {
        // Check if cbindgen is available
        self.check_cbindgen_available()?;

        let mut headers = Vec::new();

        // For now, generate one header per crate
        // In the future, we might generate per-target headers
        let header = self.generate_header_for_crate(crate_info, target_triple)?;
        headers.push(header);

        Ok(headers)
    }

    fn check_cbindgen_available(&self) -> Result<()> {
        which::which("cbindgen")
            .map_err(|_| anyhow!(
                "cbindgen not found in PATH. Install it with: cargo install cbindgen"
            ))?;
        Ok(())
    }

    fn generate_header_for_crate(&self, crate_info: &CrateInfo, target_triple: Option<&str>) -> Result<GeneratedHeader> {
        let header_path = self.get_header_path(&crate_info.name, target_triple);

        // Create cache directory
        if let Some(header_parent) = header_path.parent() {
            fs::create_dir_all(header_parent)
                .with_context(|| format!("Failed to create header cache directory: {}", header_parent.display()))?;
        }

        // Make header path absolute
        let header_path_abs = header_path.canonicalize()
            .or_else(|_| {
                // If canonicalize fails (file doesn't exist yet), make parent absolute and append filename
                let parent = header_path.parent().unwrap();
                let filename = header_path.file_name().unwrap();
                parent.canonicalize().map(|p| p.join(filename))
            })
            .with_context(|| format!("Failed to resolve absolute path for header: {}", header_path.display()))?;

        // Build cbindgen command
        let mut cmd = Command::new("cbindgen");
        cmd.arg("--crate").arg(&crate_info.name);
        cmd.arg("--output").arg(&header_path_abs);

        // Use custom config if provided
        if let Some(ref config_path) = self.cbindgen_config {
            cmd.arg("--config").arg(config_path);
        } else {
            // Use sensible defaults
            cmd.arg("--lang").arg("c");
        }

        // Set the working directory to the crate's manifest directory
        cmd.current_dir(&crate_info.manifest_dir);

        println!("Generating header for crate '{}' with cbindgen...", crate_info.name);

        let output = cmd.output()
            .context("Failed to execute cbindgen")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("cbindgen failed: {}", stderr));
        }

        // Verify the header was created
        if !header_path_abs.exists() {
            return Err(anyhow!("cbindgen completed but header file was not created: {}", header_path_abs.display()));
        }

        println!("Generated header: {}", header_path_abs.display());

        Ok(GeneratedHeader {
            crate_name: crate_info.name.clone(),
            header_path,
        })
    }

    fn get_header_path(&self, crate_name: &str, target_triple: Option<&str>) -> PathBuf {
        let target_str = target_triple.unwrap_or("native");

        self.cache_dir
            .join(target_str)
            .join("headers")
            .join(format!("{}.h", crate_name))
    }

    pub fn create_default_cbindgen_config(&self, crate_dir: &Path) -> Result<PathBuf> {
        let config_path = crate_dir.join("cbindgen.toml");

        if config_path.exists() {
            // Don't overwrite existing config
            return Ok(config_path);
        }

        let default_config = r#"
language = "C"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
include_version = true
namespace = "GlobalNamespace"

[enum]
rename_variants = "QualifiedScreamingSnakeCase"

[fn]
rename_args = "snake_case"
must_use = "MUST_USE_FUNC"

[struct]
rename_fields = "snake_case"

[export]
include = []
exclude = []
"#;

        fs::write(&config_path, default_config)
            .with_context(|| format!("Failed to write default cbindgen config to {}", config_path.display()))?;

        println!("Created default cbindgen config: {}", config_path.display());

        Ok(config_path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_header_path_generation() {
        let generator = HeaderGenerator::new(None);

        let header_path = generator.get_header_path("my_crate", Some("x86_64-unknown-linux-gnu"));

        assert!(header_path.to_string_lossy().contains("x86_64-unknown-linux-gnu"));
        assert!(header_path.to_string_lossy().contains("headers"));
        assert!(header_path.to_string_lossy().ends_with("my_crate.h"));
    }

    #[test]
    fn test_header_path_native_target() {
        let generator = HeaderGenerator::new(None);

        let header_path = generator.get_header_path("my_crate", None);

        assert!(header_path.to_string_lossy().contains("native"));
        assert!(header_path.to_string_lossy().ends_with("my_crate.h"));
    }
}